# MainCode.py

# This Python code will....
#
# The code will initiate by gathering the raw data from the three sensor types
# The Raw data from all Three sensor types will be then filtered to determine proper Digital Output or Error Statment
# The digital outputs, and status will then be sent to Dweet.io to be diplayed on Freeboard.io

# Including initial libraries

import time
import dweepy
	#Enable Raspberry Pi GPIO
import RPi.GPIO as GPIO
GPIO.setmode(GPIO.BOARD)

# Set inputs for float sensors
GPIO.setup(40, GPIO.IN)		# "" Float 
GPIO.setup(38, GPIO.IN)		# "" Float
GPIO.setup(36, GPIO.IN)		# "" Float
# Set outputs for Digitals to pump controller
GPIO.setup(11, GPIO.OUT)	# Low Output
GPIO.setup(13, GPIO.OUT)	# Medium Output
GPIO.setup(15, GPIO.OUT)	# High Output

#*******************************
#*         Variables           *
#*******************************

# Water Tank Levels in Inches
high_level = 40
medium_level = 20
low_level = 3
continuous_level_tolerance = 2 # Variable to set the allowable tolerance on how far away the continuous sensors can be from each other

#*******************************
#*        Code functions       *
#*******************************

def SendDweet(data):  # yes I am 100% aware this function will not acually be called just use the line below
	dweepy.dweet_for(sensor_name,{'data':round(data,2)})  # This line of code will be used to send a dweet to be picked up by freeboard.io

def fetchtemp():  # This function will fetch the tempurature from the DS18
	

	return tempurature

def fetchlevelpressure(): # This function will read the A/D and return the waterlevel in Inches
	

	return pressure_level

def fetchlevelAquaplumb(): # This function will read the A/D and return the waterlevel in Inches
	

	return plumb_level

def fetchlevelfloat():
	# initialize values to false
	High = False
	Medium = False
	Low = False
	
	if GPIO.input(40): # Check High Float
		High = True

	if GPIO.input(38): # Check Medium Float
		Medium = True

	if GPIO.input(36): # Check Low Float
		Low = True
	
	#Process data and prep output/Find Errors
	if(not Low and not Medium and not High):   # Empty
		float_status = 0
	elif(not Low and not Medium and High):     # Error: High Float Asserted Only
		float_status = 1
	elif(not Low and Medium and not High):     # Error: Med Float Asserted Only
		float_status = 2
	elif(not Low and Medium and High):         # Error: Low Sensor Bad
		float_status = 3
	elif(Low and not Medium and not High):     # Low 
		float_status = 4
	elif(Low and not Medium and High):         # Error: Medium Float Bad
		float_status = 5
	elif(Low and Medium and not High):         # Medium
		float_status = 6
	elif(Low and Medium and High):             # High 
		float_status = 7
	else:
		pass

	return float_status


#**************************
#*     Main Function      *
#**************************

while True:		# while True: creates an infinate while loop to run while the Pi is on

	# Fetch Water Levels
	float_level = fetchlevelfloat()
	pressure_level = fetchlevelpressure()
	plumb_level = fetchlevelAquaplumb()


	cont_difference = abs(pressure_level - float_level)	# Check Continuous level floats for Error
	if(cont_difference > continuous_level_tolerance): # Error in Continuous Sensors --- tolerance currently set to 2"
		# Implement Logic to figure out what continuous sensor failed
		if((float_level == 1 ) or (float_level == 2 ) or (float_level == 3 ) or (float_level == 5 )):   # Error Condition in Float Sensors
			print("Sensor Error: Float & Continuous Sensor Failure")
			print("Please in inspect Sensor Stack")
			# SHUT DOWN CODE
			GPIO.output(11, True)
			GPIO.output(13, False)
			GPIO.output(15, True)
			#while True:   # This while loop would potentially lock up the system until george reboots the pi / power cycles unit
			#	time.sleep(10)
			#

		else: # No Error in Float Sensors >>> Deside what type of continuous sensor is bad 
			# Check based on floats values 0, 4, 6, 7
			if(float_level == 0):  # Float = Empty
				if(pressure_level <= low_level and plumb_level <= low_level) # all three sensors agree, continuous failure not found. 
					GPIO.output(11, True)
					GPIO.output(13, True)
					GPIO.output(15, True)
				elif(pressure_level <= low_level): # Pressure Level Sensor agrees >>> Aquaplumb Error
					print("Sensor Error: Aquaplumb Sensor Failure")
					GPIO.output(11, True)
					GPIO.output(13, True)
					GPIO.output(15, True)					
				elif(plumb_level <= low_level): # Aquaplumb Sensor agrees >>> Pressure Error
					print("Sensor Error: Pressure Sensor Failure")
					GPIO.output(11, True)
					GPIO.output(13, True)
					GPIO.output(15, True)
				else: 
					pass

			elif(float_level == 4): # Float = Low
				if(low_level <= pressure_level <= medium_level and low_level <= plumb_level <= medium_level) # all three sensors agree, continuous failure not found. 
					GPIO.output(11, False)
					GPIO.output(13, True)
					GPIO.output(15, True)
				elif(low_level <= pressure_level <= medium_level): # Pressure Level Sensor agrees >>> Aquaplumb Error
					print("Sensor Error: Aquaplumb Sensor Failure")
					GPIO.output(11, False)
					GPIO.output(13, True)
					GPIO.output(15, True)					
				elif(low_level <= plumb_level <= medium_level): # Aquaplumb Sensor agrees >>> Pressure Error
					print("Sensor Error: Pressure Sensor Failure")
					GPIO.output(11, False)
					GPIO.output(13, True)
					GPIO.output(15, True)
				else: 
					pass

			elif(float_level == 6): # Float = Med
				if(medium_level <= pressure_level <= high_level and medium_level <= plumb_level <= high_level) # all three sensors agree, continuous failure not found. 
					GPIO.output(11, False)
					GPIO.output(13, False)
					GPIO.output(15, True)
				elif(medium_level <= pressure_level <= high_level): # Pressure Level Sensor agrees >>> Aquaplumb Error
					print("Sensor Error: Aquaplumb Sensor Failure")
					GPIO.output(11, False)
					GPIO.output(13, False)
					GPIO.output(15, True)
				elif(medium_level <= plumb_level <= high_level): # Aquaplumb Sensor agrees >>> Pressure Error
					print("Sensor Error: Pressure Sensor Failure")
					GPIO.output(11, False)
					GPIO.output(13, False)
					GPIO.output(15, True)
				else: 
					pass

			elif(float_level == 7): # Float = High
				if(pressure_level >= high_level and plumb_level >= high_level) # all three sensors agree, continuous failure not found. 
					GPIO.output(11, False)
					GPIO.output(13, False)
					GPIO.output(15, False)
				elif(pressure_level >= high_level): # Pressure Level Sensor agrees >>> Aquaplumb Error
					print("Sensor Error: Aquaplumb Sensor Failure")
					GPIO.output(11, False)
					GPIO.output(13, False)
					GPIO.output(15, False)
				elif(plumb_level >= high_level): # Aquaplumb Sensor agrees >>> Pressure Error
					print("Sensor Error: Pressure Sensor Failure")
					GPIO.output(11, False)
					GPIO.output(13, False)
					GPIO.output(15, False)
				else: 
					pass

			else:
				pass

	else: # No Error in continuous sensors
		continuous_level = (pressure_level + plumb_level)/2
		print('The Water Level in the Tank is: ', continuous_level)

		if((float_level == 0 ) or (float_level == 4 ) or (float_level == 6 ) or (float_level == 7 )):   # No Errors in Float Sensors
			#Implment Logic to determine the digital outputs ASSUMING NO ERRORS
			if(float_level == 0 and continuous_level <= low_level + 1):	# Output "Empty" to pump controller
				GPIO.output(11, True)
				GPIO.output(13, True)
				GPIO.output(15, True)
			elif(float_level == 4 and low_level - 1 <= continuous_level <= medium_level + 1):  # Output "Low" to pump controller
				GPIO.output(11, False)
				GPIO.output(13, True)
				GPIO.output(15, True)
			elif(float_level == 6 and medium_level - 1 <= continuous_level <= high_level):  # Output "Med" to pump controller
				GPIO.output(11, False)
				GPIO.output(13, False)
				GPIO.output(15, True)
			elif(float_level == 7 and continuous_level >= high_level - 1):  # Output "High" to pump controller
				GPIO.output(11, False)
				GPIO.output(13, False)
				GPIO.output(15, False)
			else:
				pass

		else:  # Error in float sensors but not continuous sensors
			print("Sensor Error: Float Sensor Failure")
			print("Please in inspect Floats")

			# Trust continuous sensors
			if(continuous_level <= low_level):	# Output "Empty" to pump controller
				GPIO.output(11, True)
				GPIO.output(13, True)
				GPIO.output(15, True)
			elif(low_level <= continuous_level <= medium_level):  # Output "Low" to pump controller
				GPIO.output(11, False)
				GPIO.output(13, True)
				GPIO.output(15, True)
			elif(medium_level <= continuous_level <= high_level):  # Output "Med" to pump controller
				GPIO.output(11, False)
				GPIO.output(13, False)
				GPIO.output(15, True)
			elif(continuous_level >= high_level):  # Output "High" to pump controller
				GPIO.output(11, False)
				GPIO.output(13, False)
				GPIO.output(15, False)
			else:
				pass


	# Fetch and Report Tempurature level.
		# Fetch Tempurature and Display it freeboard.io site: 
	tempurature = fetchtemp()
	dweepy.dweet_for(sensor_name,{'tempurature':round(data,2)})


	time.sleep(3)  #This line will delay the code for 3 seconds




#********************
#*      Notes       *
#********************
"""
	Float Sensor truth table 

  |	 Low  Med  High |  Results
0 |	  0    0    0   |  Empty 
1 |   0    0    1   |  Error: high float asserted only
2 |   0    1    0   |  Error: Medium float asserted only
3 |   0    1    1   |  Error: Med and High float asserted (check low float)
4 |   1    0    0   |  Low
5 |   1    0    1   |  Error: Low and Medium float asserted (check medium float)
6 |   1    1    0   |  Medium
7 |   1    1    1   |  High

	
	Tank Level Schematic 

			48" --- 
				 |
				 |   High
				 |
	  High: 40" ---
				 |
				 |   Medium
				 |
	   Med: 20" ---
	   			 |
	   			 |   Low
	   			 |
	    Low: 3" ---
	    	     |
	    	     |   Empty
	    	     |
	    	 0" ---


	Python Coding Notes

In order to set ports to an input or output
GPIO.setup(Port#, GPIO.IN)  // input
GPIO.setup(Port#, GPIO.OUT) // output
In this senerio BOARD is selected so the port #'s
will match the Port # on the Pi

In order to Read the Value of an input 
GPIO.input(port#)

In order to set the output state of a GPIO pin:
GPIO.output(Port#, state)  // were state can be 0 / 1 / False / True / GPIO.LOW / GPIO.HIGH




"""
