# MainCode.py

# This Python code will....
#
# The code will initiate by gathering the raw data from the three sensor types
# The Raw data from all Three sensor types will be then filtered to determine proper Digital Output or Error Statment
# The digital outputs, and status will then be sent to Dweet.io to be diplayed on Freeboard.io

# Including initial libraries

import time
import dweepy
	#Enable Raspberry Pi GPIO
import RPi.GPIO as GPIO
GPIO.setmode(GPIO.BOARD)

# Set inputs for float sensors
GPIO.setup(40, GPIO.IN)		# "" Float 
GPIO.setup(38, GPIO.IN)		# "" Float
GPIO.setup(36, GPIO.IN)		# "" Float
# Set outputs for Digitals to pump controller
GPIO.setup(11, GPIO.OUT)	# Low Output
GPIO.setup(13, GPIO.OUT)	# Medium Output
GPIO.setup(15, GPIO.OUT)	# High Output

#*******************************
#*         Variables           *
#*******************************

# Water Tank Levels in Inches
high_level = 40
medium_level = 20
low_level = 3
continuous_level_tolerance = 2 # Variable to set the allowable tolerance on how far away the continuous sensors can be from each other

#*******************************
#*        Code functions       *
#*******************************

def SendDweet(data):  # yes I am 100% aware this function will not acually be called just use the line below
	dweepy.dweet_for(sensor_name,{'data':round(data,2)})  # This line of code will be used to send a dweet to be picked up by freeboard.io

def fetchtemp():  # This function will fetch the tempurature from the DS18
	lkjasfdjlafsdljkafd

	return tempurature

def fetchlevelpressure(): # This function will read the A/D and return the waterlevel in Inches
	dfdfdsf

	return pressure_level

def fetchlevelAquaplumb(): # This function will read the A/D and return the waterlevel in Inches
	lkjasfdjlafsdljkafd

	return plumb_level


def fetchlevelfloat():
	# initialize values to false
	High = False
	Medium = False
	Low = False
	
	if GPIO.input(40): # Check High Float
		High = True

	if GPIO.input(38): # Check Medium Float
		Medium = True

	if GPIO.input(36): # Check Low Float
		Low = True
	
	#Process data and prep output/Find Errors
	if(not Low and not Medium and not High):   # Empty
		float_status = 0
	elif(not Low and not Medium and High):     # Error: High Float Asserted Only
		float_status = 1
	elif(not Low and Medium and not High):     # Error: Med Float Asserted Only
		float_status = 2
	elif(not Low and Medium and High):         # Error: Low Sensor Bad
		float_status = 3
	elif(Low and not Medium and not High):     # Low 
		float_status = 4
	elif(Low and not Medium and High):         # Error: Medium Float Bad
		float_status = 5
	elif(Low and Medium and not High):         # Medium
		float_status = 6
	elif(Low and Medium and High):             # High 
		float_status = 7
	else:
		pass


	return float_status


#**************************
#*     Main Function      *
#**************************

while True:		# while True: creates an infinate while loop to run while the Pi is on

	# Fetch Water Levels
	float_level = fetchlevelfloat()
	pressure_level = fetchlevelpressure()
	plumb_level = fetchlevelAquaplumb()

	if((float_level == 1 ) or (float_level == 2 ) or (float_level == 3 ) or (float_level == 5 )):   # Error Condition in Float Sensors
		print("Sensor Error: Float Sensor Failure")
		print("Please in inspect Floats")
		# Possible break the Loop and wait for maintance.
	else:  # No Error Condition in Float Sensors
		cont_difference = abs(pressure_level - float_level)	# Check Continuous level floats for Error
		if(cont_difference > continuous_level_tolerance): # Error in Continuous Sensors --- tolerance currently set to 2"
			# Implement Logic to figure out what continuous sensor failed
			find_continuous_failure(): # to be implemented later
			if cont_error = 0:   # Aquaplumb error
				print("Sensor Error: AquaPlumb Continuous Sensor Failure")
			else: # Pressure Sensor Error
				print("Sensor Error: Pressure Based Continuous Sensor Failure")
		else:
			continuous_level = (pressure_level + plumb_level)/2 # if the continuous sensors agree then an Average of the two will be used in the voting scheme
			pass # Move on with logic cause nothing is bad

	#Implment Logic to determine the digital outputs ASSUMING NO ERRORS
	if(float_level == 0 and pressure_level <= Low + 1 and plumb_level <= Low + 1):	# Output "Empty" to pump controller
		GPIO.output(11, True)
		GPIO.output(13, True)
		GPIO.output(15, True)
	elif(float_level == 4 and low_level - 1 <= pressure_level <= medium_level + 1 and low_level - 1 <= plumb_level <= medium_level + 1):  # Output "Low" to pump controller
		GPIO.output(11, False)
		GPIO.output(13, True)
		GPIO.output(15, True)
	elif(float_level == 6 and medium_level - 1 <= pressure_level <= high_level and low_level - 1 <= plumb_level <= medium_level):  # Output "Med" to pump controller
		GPIO.output(11, False)
		GPIO.output(13, False)
		GPIO.output(15, True)
	elif(float_level == 7 and pressure_level >= high_level - 1 and plumb_level >= high_level):  # Output "High" to pump controller
		GPIO.output(11, False)
		GPIO.output(13, False)
		GPIO.output(15, False)
	else:
		pass

	
	continuous_level = (pressure_level + plumb_level)/2 # if the continuous sensors agree then an Average of the two will be used in the voting scheme

	# Fetch Tempurature and Display it freeboard.io site: 
	tempurature = fetchtemp()
	dweepy.dweet_for(sensor_name,{'tempurature':round(data,2)})


	time.sleep(3)  #This line will delay the code for 3 seconds




#********************
#*      Notes       *
#********************
"""
In order to set ports to an input or output
GPIO.setup(Port#, GPIO.IN)  // input
GPIO.setup(Port#, GPIO.OUT) // output
In this senerio BOARD is selected so the port #'s
will match the Port # on the Pi

In order to Read the Value of an input 
GPIO.input(port#)

In order to set the output state of a GPIO pin:
GPIO.output(Port#, state)  // were state can be 0 / 1 / False / True / GPIO.LOW / GPIO.HIGH


"""
